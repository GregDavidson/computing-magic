* Exercise: Make A Face in Racket

This exercise is part of [[https://github.com/GregDavidson/computing-magic/blob/main/Modules/Module-1/module-1.org][Computing Magic Module-1]]

Learn
- Progressive Development
- Parameterization
- Use of Libraries

Prerequisites
- [[https://docs.racket-lang.org/quick][Racket Quick Tutorial]]

*This is a progressive exercise: Look at only *one step at a time!*
- You might read this OrgMode version with Emacs
      - Fold and Unfold sections with TAB
- Or a /Folding Version/ as a WebPage.
      - Not yet available for this document
- Otherwise, try not to look at the example solutions
      - Until you've tried to make your own

** Step 1: Make an Eye Interactively

Look up the procedures 
- filled-ellipse
- disk
from [[https://docs.racket-lang.org/pict/Basic_Pict_Constructors.html][Basic Pict Constructors]] and
- cc-superimpose
from [[https://docs.racket-lang.org/pict/Pict_Combiners.html][Pict Combiners]]

Use these interactively to create a picture resembling an eye with iris and
pupil.

First make the parts of the picture one at a time, then nest them with
cc-superimpose to create the desired result.

** Step 1: Example Solution

This is only an example illustrating a possible solution. Your solution might be
different from this example and still be just as good or better. The important
thing is that you're learning what you can do with nesting these and similar
forms.

#+begin_src racket
  (cc-superimpose
   (filled-ellipse 100 50 #:color (light"lightyellow"))
   (disk 45 #:color "lightblue")
   (disk 15 #:color "black") ) 
#+end_src

** Step 2: Make Using A Parameterized Procedure

Turn a solution to Step 1 into a Parameterized Procedure.
- Turn all numbers into parameters
- Would it be nicer to make any of them be ratios?
- Try using let or let* to temporarily bind values

Turn at least one of the colors into a parameter.

Call your procedure with different values for its parameters.
- How convenient is it to have so many parameters?

#+begin_src racket
  (define (make-eye YOUR PARAMETERS HERE)
    (cc-superimpose
     (filled-ellipse YOUR ARGUMENTS HERE)
     (disk YOUR ARGUMENTS HERE)
     (disk YOUR ARGUMENTS HERE) ) )
#+end_src

** Step 2: Example Solution

Usual Caveat that this is only one way to do it.

#+begin_src racket
  (define (make-eye eye-height eye-ratio iris-ratio pupil-ratio iris-color)
    (let* ( [eye-width (* eye-ratio eye-height)]
            [iris-size (* iris-ratio eye-height)]
            [pupil-size (* pupil-ratio iris-size)] )
      (cc-superimpose
       (filled-ellipse eye-width eye-height #:color "lightyellow")
       (disk iris-size #:color iris-color)
       (disk pupil-size #:color "black") ) ) )
#+end_src

#+begin_src racket
  ; Example call to make-eye
  (make-eye 100 2 4/5 2/5 "brown")
#+end_src

** Step 3: Leverage Named and Optional Parameters

It is considered good style to generalize procedures by replacing any arbitrary
values with parameters. Yet it is awkward to work with a procedure which has
lots of positional parameters
- Specifying values for all parameters is tedious
- Remembering what each parameter does is difficult

Look at the sections on
- Declaring Optional Arguments
- Declaring Keyword Arguments
in [[https://docs.racket-lang.org/guide/lambda.html][Racket Guide: Creating Procedures with Lambda]]

Good practice is to
- Require positional parameters for only a few essential parameters
- Use keywords to name additional parameters
- Make parameters optional where there's a single common default value

Define your procedure so that these are both legitimate calls:
#+begin_src racket
  (make-eye 100)
  (make-eye 100 #:color "brown" #:ratio 2 #:pupil 1/5)
#+end_src


** Step 3: Example Solution

Usual Caveat that this is only one way to do it.

#+begin_src racket
  (define (make-eye eye-height #:ratio [eye-ratio 2]
                #:iris [iris-ratio 4/5] #:pupil [pupil-ratio 2/5]
                #:color [iris-color "brown"]
                #:sclera-color [sclera-color "lightyellow"] )
  (let* ( [eye-width (* eye-ratio eye-height)]
          [iris-size (* iris-ratio eye-height)]
          [pupil-size (* pupil-ratio iris-size)] )
    (cc-superimpose
     (filled-ellipse eye-width eye-height #:color sclera-color)
     (disk iris-size #:color iris-color)
     (disk pupil-size #:color "black") ) ) )
#+end_src

** Step 4: Build up to Making A Face

You're going to create a series of procedures. Each will have some parameters.
Later procedures will call some of your earlier procedures. You will need to
propagate parameter values appropriately to the procedures which you're calling.

Suggested flow:
- Create a procedure for making two eyes.
      - optional first argument of append functions specifies spacing
- Create a procedure for making a nose
      - make it simple for now, e.g. a disk
- Create a procedure for making eyes+nose
      - Calling your earlier two procedures
- Create a procedure for making a mouth
      - make it simple for now, e.g. a filled ellipse
- Create a procedure for making eyes+nose+mouth
      - Calling your earlier two procedures

Procedures you may find useful:
- pict-width from [[https://docs.racket-lang.org/pict/Pict_Datatype.html][Pict Datatype]]
- pin-over from [[https://docs.racket-lang.org/pict/Pict_Combiners.html][Pict Combiners]]

Some of these procedures will be
- taking the same optional arguments as the procedures they're calling
- passing these arguments on unchanged
We should not repeat default values
- we'll store them in global bindings for now
- this will create some redundancy
- but will allow us test each part separately
      - this is an example of *loose coupling*

#+begin_src racket
  ;; Define defaults for eye procedures
  (define eye-ratio 2)
  (define eye-iris-ratio 4/5)
  (define eye-iris-pupil-ratio 2/5)
  (define eye-color "brown")
  (define eye-sclera-color "lightyellow")
  (define eye-spacing-ratio 1/3)

  (define (make-eye eye-height #:ratio [eye-ratio eye-ratio]
                    #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                    #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color] )
    (let* ( [eye-width (* eye-ratio eye-height)]
            [iris-size (* iris-ratio eye-height)]
            [pupil-size (* pupil-ratio iris-size)] )
      (cc-superimpose
       (filled-ellipse eye-width eye-height #:color sclera-color)
       (disk iris-size #:color iris-color)
       (disk pupil-size #:color "black") ) ) )

  (define (make-eyes eye-height
                     #:spacing-ratio [spacing-ratio eye-spacing-ratio]
                     #:ratio [eye-ratio eye-ratio]
                     #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                     #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color] )
    'YOUR-CODE-GOES-HERE! )
#+end_src


** Step 4: Example Solution with Loose Coupling

Usual Caveat that this is only one way to do it.

A solution like this would not be produced all at once!!!

#+begin_src racket
  ;; Define defaults for eye procedures
  (define eye-ratio 2)
  (define eye-iris-ratio 4/5)
  (define eye-iris-pupil-ratio 2/5)
  (define eye-color "brown")
  (define eye-sclera-color "lightyellow")
  (define eye-spacing-ratio 1/3)
  ;; Define defaults for eyes+nose+mouth and face
  (define face-color "tan")
  (define face-border-width 2)
  (define face-border-color "black")
  (define face-ratio 3/4)
  (define face-eye-ratio 1/7)
  (define face-nose-ratio 1/8)
  (define face-mouth-ratio 1/3)
  (define face-nose-mouth-ratio 1/8)
  (define face-content-ratio 1/3)
  (define mouth-ratio 1/4)
  (define mouth-color "red")

  (define (make-eye eye-height
                    #:ratio [eye-ratio eye-ratio]
                    #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                    #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color] )
    (let* ( [eye-width (* eye-ratio eye-height)]
            [iris-size (* iris-ratio eye-height)]
            [pupil-size (* pupil-ratio iris-size)] )
      (cc-superimpose
       (filled-ellipse eye-width eye-height #:color sclera-color)
       (disk iris-size #:color iris-color)
       (disk pupil-size #:color "black") ) ) )


  (define (make-eyes eye-height
                     #:spacing-ratio [spacing-ratio eye-spacing-ratio]
                     #:ratio [eye-ratio eye-ratio]
                     #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                     #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color] )
    (let ([eye (make-eye eye-height #:ratio eye-ratio #:iris iris-ratio #:pupil pupil-ratio
                         #:color iris-color #:sclera-color sclera-color )])
      (hc-append (* spacing-ratio eye-ratio eye-height) eye eye) ) )

  (define (make-nose size) (disk size))

  (define (make-eyes+nose face-height
                          #:face-eye-ratio [face-eye-ratio face-eye-ratio]
                          #:ratio [eye-ratio eye-ratio]
                          #:spacing-ratio [eye-spacing-ratio eye-spacing-ratio]
                          #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                          #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color]
                          #:face-nose-ratio [face-nose-ratio face-nose-ratio] #:eye-nose-spacing [eye-nose-spacing 0] )
    (printf "~a\n" `(vc-append ,eye-nose-spacing
                               (make-eyes ,(* face-height face-eye-ratio))
                               (make-nose ,(* face-height face-nose-ratio)) ))
    (vc-append eye-nose-spacing
               (make-eyes (* face-height face-eye-ratio)
                          #:ratio eye-ratio #:spacing-ratio eye-spacing-ratio
                          #:iris iris-ratio #:pupil pupil-ratio
                          #:color iris-color #:sclera-color sclera-color )
               (make-nose (* face-height face-nose-ratio)) ) )

  (define (make-mouth width #:ratio [ratio mouth-ratio] #:color [color mouth-color])
    (filled-ellipse width (* ratio width) #:color color) )

  (define (make-eyes+nose+mouth face-height
                                #:nose-mouth-ratio [nose-mouth-ratio face-nose-mouth-ratio]
                                #:face-eye-ratio [face-eye-ratio face-eye-ratio]
                                #:eye-ratio [eye-ratio eye-ratio]
                                #:eye-spacing-ratio [eye-spacing-ratio eye-spacing-ratio]
                                #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                                #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color]
                                #:face-nose-ratio [face-nose-ratio face-nose-ratio] #:eye-nose-spacing [eye-nose-spacing 0]
                                #:face-mouth-ratio [face-mouth-ratio face-mouth-ratio] #:mouth-color [mouth-color mouth-color] )
    (let* ( [spacing (* nose-mouth-ratio face-height)] )
      (vc-append spacing
                 (make-eyes+nose face-height
                                 #:face-eye-ratio face-eye-ratio
                                 #:ratio eye-ratio #:spacing-ratio eye-spacing-ratio
                                 #:iris iris-ratio #:pupil pupil-ratio
                                 #:color iris-color #:sclera-color sclera-color
                                 #:face-nose-ratio face-nose-ratio #:eye-nose-spacing eye-nose-spacing
                                 )
                 (make-mouth (* face-height face-mouth-ratio) #:ratio face-mouth-ratio #:color mouth-color) ) ) )

  (define (make-face height  #:ratio [ratio face-ratio]
                #:color [color face-color]
                #:border-width [border-width face-border-width]
                #:nose-mouth-ratio [nose-mouth-ratio face-nose-mouth-ratio]
                #:content-ratio [content-ratio face-content-ratio]
                #:face-eye-ratio [face-eye-ratio face-eye-ratio]
                #:eye-ratio [eye-ratio eye-ratio]
                #:eye-spacing-ratio [eye-spacing-ratio eye-spacing-ratio]
                #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                #:eye-color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color]
                #:nose-ratio [nose-ratio face-nose-ratio] #:eye-nose-spacing [eye-nose-spacing 0]
                #:mouth-ratio [mouth-ratio face-mouth-ratio] #:mouth-color [mouth-color mouth-color] )
    (let* ( [width (* ratio height)]
            [content (make-eyes+nose+mouth height
                                           #:nose-mouth-ratio nose-mouth-ratio #:face-eye-ratio face-eye-ratio
                                           #:eye-ratio eye-ratio #:eye-spacing-ratio eye-spacing-ratio
                                           #:iris iris-ratio #:pupil pupil-ratio
                                           #:color iris-color #:sclera-color sclera-color
                                           #:face-nose-ratio nose-ratio #:eye-nose-spacing eye-nose-spacing
                                           #:face-mouth-ratio mouth-ratio #:mouth-color mouth-color )]
            [margin (/ (- width (pict-width content)) 2)] )
      (printf "~a\n" `(filled-ellipse ,width ,height #:color ,color #:border-width ,border-width))
      (printf "dx: ~s, dy: ~s\n" margin (* content-ratio height))
      (pin-over
       (filled-ellipse width height #:color color #:border-width border-width)
       margin (* content-ratio height) content ) ) )

#+end_src

** Step 4: A Prettier Solution with Tight Coupling

If we define each procedure inside of the scope of the procedure which calls us,
we can get rid of all of this redundancy. However, we also get rid of the ease
of running and testing each piece independently.

Here it is, do you like it?  Do the comments help you see the scopes?

#+begin_src racket
   #lang slideshow

  (define (make-face face-height
                     #:ratio [face-ratio 3/4]
                     #:color [color "tan"]
                     #:border-width [border-width 2]
                     #:nose-mouth-ratio [nose-mouth-ratio 1/8]
                     #:content-ratio [content-ratio 1/3]
                     #:face-eye-ratio [face-eye-ratio 1/7]
                     #:eye-ratio [eye-ratio 2]
                     #:eye-spacing-ratio [eye-spacing-ratio 1/3]
                     #:iris [iris-ratio 4/5]
                     #:pupil [pupil-ratio 2/5]
                     #:eye-color [eye-color "brown"]
                     #:sclera-color [sclera-color "lightyellow"]
                     #:nose-ratio [nose-ratio 1/8]
                     #:eye-nose-spacing [eye-nose-spacing 0]
                     #:face-mouth-ratio [face-mouth-ratio 1/8]
                     #:mouth-ratio [mouth-ratio 1/4]
                     #:mouth-color [mouth-color "red"] )

    ;; we're still inside the scope of make-face

    (define (make-mouth width #:ratio [ratio mouth-ratio] #:color [color mouth-color])
      (filled-ellipse width (* ratio width) #:color color) )

    (define (make-eyes+nose+mouth)

      ;; we're inside the scope of make-eyes+nose+mouth

      (define (make-eyes+nose)

        ;; we're inside the scope of make-eyes+nose

        (define (make-eyes eye-height)

          ;; we're inside the scope of make-eyes

          (define (make-eye)
            (let* ( [eye-width (* eye-ratio eye-height)]
                    [iris-size (* iris-ratio eye-height)]
                    [pupil-size (* pupil-ratio iris-size)] )
              (cc-superimpose
               (filled-ellipse eye-width eye-height #:color sclera-color)
               (disk iris-size #:color eye-color)
               (disk pupil-size #:color "black") ) ) )

          ;; make-eyes body
          (let ( [eye (make-eye)] )
            (hc-append (* eye-spacing-ratio eye-ratio eye-height) eye eye) ) )

        (define (make-nose size) (disk size))

        ;; make-eyes+nose body
        (vc-append eye-nose-spacing
                   (make-eyes (* face-height face-eye-ratio))
                   (make-nose (* face-height nose-ratio)) ) )

      (define (make-mouth width)
        (filled-ellipse width (* mouth-ratio width) #:color mouth-color) )

      ;; make-eyes+nose+mouth body
      (let* ( [spacing (* nose-mouth-ratio face-height)] )
        (vc-append spacing
                   (make-eyes+nose)
                   (make-mouth (* face-height face-mouth-ratio) ) ) ) )

    ;; make-face body
    (let* ( [width (* face-ratio face-height)]
            [content (make-eyes+nose+mouth)]
            [margin (/ (- width (pict-width content)) 2)] )
      (pin-over
       (filled-ellipse width face-height #:color color #:border-width border-width)
       margin (* content-ratio face-height) content ) ) )

  ;; Example Call
  (make-face 100)
#+end_src

** Step 4: Discussion: Can we have it all?

The first example solution is very /hackable/
- You can explore the solution space experimentally in the repl
- The parameters and their defaults are easy to modify
- Each function is easy to call independently

The problem is that there's a lot of repeated boilerplace
- Many similar keyword arguments are repeated across multiple functions
- The global bindings with the argument defaults also seem syntactically repetitious

How can we have the hackability without the rigidity of nested scopes?

1. Modify the repl or debugger to allow issuing commands inside nested scopes
       - Has anyone already done this?
2. Write a macro to allow defining a named group of
   keyword/parameter-names/default-values compactly and reusing it flexibly
       - Macros are one of Lisp's superpowers
       - This might wind up being a very useful language extension!
       - With set operations for such argument groups, relationships among
         procedure APIs could be made both more explicit and more compact!
       - Such should also allow easy delegation of groups of applicable
         arguments to sub-procedures!
3. Use class objects with inheritance to store the groups of arguments.
       - Advantage: Such is already be provided in Racket and most other Lisps
       - Disadvantage: Some runtime overhead and possibly additional complexity.

Questions:
1. What might these approaches look like?
2. What other approaches can you think of?
3. What's already been done in this design space?
4. Would you like to learn about
       - Racket (or other Lisp) macros?
       - Racket (or other Lisp) class and object systems?

** Step Infinity: Complex Objects, e.g. Noses, Mouths, Eyelids, etc.

Once you determine what you want to be able to make you can select the right
tools from Racket's libraries.

*** Browsing the High-Level Libraries

There are more useful procedures in the pict library. Some of them are packaged
in sub-libraries and so they need a require form:

#+begin_src racket
  (require pict/color)

  (make-eye 30 #:color (light "aquamarine"))
#+end_src

Racket provides other easy-to-use high-level libraries for graphics, e.g.
Pict3D for creating 3D images.

Browse the section /GUI and Graphics Libraries/ in the
- [[https://docs.racket-lang.org][Racket Documentation Webpage]]

Two of the high-level graphics systems provide [[https://en.wikipedia.org/wiki/B%C3%A9zier_curve][Bézier Curves]] which can compactly
describe many complex curves and surfaces:
- [[https://docs.racket-lang.org/metapict/index.html#%28part._ref-bez%29][Bezier Curves]] in the [[https://docs.racket-lang.org/metapict/index.html][MetaPict Library]]
- [[https://docs.racket-lang.org/manual-sketching/Examples.html#%28part._example_bezier%29][Bezier]] in the [[https://docs.racket-lang.org/manual-sketching/index.html][Sketching Library/Language]]

*** Learning the Lower-Level Racket Drawing Toolkit

Racket's high-level libraries are based on the lower level [[https://docs.racket-lang.org/draw/index.html][Racket Drawing Toolkit]]

If you find the existing high-level libraries too limited for
something you want to do, you can use the Racket Drawing Toolkit directly.

You can also use the Racket Drawing Toolkit selectively in combination with
higher level Racket libraries.

The Racket Drawing Toolkit leverages Racket's ability to do /Object Oriented
Programming/ to manage the complexity of low level graphics.

Here's the [[https://docs.racket-lang.org/draw/overview.html][Racket Drawing Toolkit Overview]]

Here's an example you can run in DrRacket:

#+begin_src racket
  #lang racket

  (require pict)
  (require racket/draw)

  (define (make-fancy-triangle w h)
    (dc (λ (dc dx dy)
          (define old-brush (send dc get-brush))
          (define old-pen (send dc get-pen))
          (send dc set-brush
                (new brush% [style 'fdiagonal-hatch]
                     [color "darkslategray"] ) )
          (send dc set-pen
                (new pen% [width 3] [color "slategray"]) )
          (define path (new dc-path%))
          (send path move-to 0 0)
          (send path line-to 50 0)
          (send path line-to 25 50)
          (send path close)
          (send dc draw-path path dx dy)
          (send dc set-brush old-brush)
          (send dc set-pen old-pen) )
        w h ) )

  ;; try: (make-fancy-triangle 50 50)
#+end_src

Notice that we're still using our familiar pict library so we can mix and match
high-level pict functions with the low-level Racket Drawing Toolkit features.

** Bitmaps

The Racket Making Library can create and manipulate Bitmaps directly.

Existing images in files can be loaded into bitmaps in several ways, e.g.
- (make-object bitmap% PATH-TO-FILE-AS-STRING KIND)
- where KIND is an image File Format identified by one of these symbols:
      - 'gif 'gif/mask 'gif/alpha
      - 'jpeg 'jpeg/alpha
      - 'png 'png/mask 'png/alpha
      - 'xbm 'xbm/alpha 'xpm 'xpm/alpha
      - 'bmp 'bmp/alpha

Bitmaps have a fixed resolution.

** SVG = Scalable Vector Graphics

The Racket Making Library can also work with SVGs which can be scaled to fit
any resolution.

The Racket Making Tookit can use SVGs by using the [[https://docs.racket-lang.org/draw/svg-dc_.html][Drawing Class svg-dc%]]

The making methods are the same as making on a bitmap, but the result is often
nicer.
