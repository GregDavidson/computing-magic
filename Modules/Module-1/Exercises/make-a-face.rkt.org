* Exercise: Make A Face in Racket

This exercise is part of [[https://github.com/GregDavidson/computing-magic/blob/main/Modules/Module-1/module-1.org][Computing Magic Module-1]]

Learn
- Progressive Development
- Parameterization
- Use of Libraries

Prerequisites
- [[https://docs.racket-lang.org/quick][Racket Quick Tutorial]]

*This is a progressive exercise: Look at only *one step
at a time!* Ideally:
- Read the OrgMode version with Emacs
- Or a /Folding Version/ as a WebPage.

** Step 1: Make an Eye Interactively

Look up the procedures 
- filled-ellipse
- disk
from [[https://docs.racket-lang.org/pict/Basic_Pict_Constructors.html][Basic Pict Constructors]] and
- cc-superimpose
from [[https://docs.racket-lang.org/pict/Pict_Combiners.html][Pict Combiners]]

Use these interactively to create a picture resembling an eye with iris and
pupil.

First make the parts of the picture one at a time, then nest them with
cc-superimpose to create the desired result.

** Step 1: Example Solution

This is only an example illustrating a possible solution. Your solution might be
different from this example and still just as good or better. The important
thing is that you're learning what you can do with nesting these and similar
forms.

#+begin_src racket
  (cc-superimpose
   (filled-ellipse 100 50 #:color (light"lightyellow"))
   (disk 45 #:color "lightblue")
   (disk 15 #:color "black") ) 
#+end_src

** Step 2: Make Using A Parameterized Procedure

Turn a solution to Step 1 into a Parameterized Procedure.
- Turn all numbers into parameters
- Would it be nicer to make any of them be ratios?
- Try using let or let* to temporarily bind values

Turn at least one of the colors into a parameter.

Call your procedure with different values for its paramters.
- How convenient is it to have so many parameters?

#+begin_src racket
  (define (make-eye YOUR PARAMETERS HERE)
    (cc-superimpose
     (filled-ellipse YOUR ARGUMENTS HERE)
     (disk YOUR ARGUMENTS HERE)
     (disk YOUR ARGUMENTS HERE) ) )
#+end_src

** Step 2: Example Solution

Usual Caveat that this is only one way to do it.

#+begin_src racket
  (define (make-eye eye-height eye-ratio iris-ratio pupil-ratio iris-color)
    (let* ( [eye-width (* eye-ratio eye-height)]
            [iris-size (* iris-ratio eye-height)]
            [pupil-size (* pupil-ratio iris-size)] )
      (cc-superimpose
       (filled-ellipse eye-width eye-height #:color "lightyellow")
       (disk iris-size #:color iris-color)
       (disk pupil-size #:color "black") ) ) )
#+end_src

#+begin_src racket
  ; Example call to eye1
  (make-eye 100 2 4/5 2/5 "brown")
#+end_src

** Step 3: Leverage Named and Optional Parameters

It is considered good style to generalize procedures by replacing any
arbitrary values with parameters.  Yet it is awkward to work with a procedure whic
has lots of positional parameters
- Specifying values for all parameters is tedius
- Remembering what each parameter does is difficult

Look at the sections on
- Declaring Optional Arguments
- Declaring Keyword Arguments
in [[https://docs.racket-lang.org/guide/lambda.html][Racket Guide: Creating Procedures with Lambda]]

Good practice is to
- Require positional parameters for only a few essential parameters
- Use keywords to name additional parameters
- Make parameters optional where there's a single common default value

Define your procedure so that these are both legitimate calls:
#+begin_src racket
  (make-eye 100)
  (make-eye 100 #:color "brown" #:ratio 2 #:pupil 1/5)
#+end_src


** Step 3: Example Solution

Usual Caveat that this is only one way to do it.

#+begin_src racket
  (define (make-eye eye-height #:ratio [eye-ratio 2]
                #:iris [iris-ratio 4/5] #:pupil [pupil-ratio 2/5]
                #:color [iris-color "brown"]
                #:sclera-color [sclera-color "lightyellow"] )
  (let* ( [eye-width (* eye-ratio eye-height)]
          [iris-size (* iris-ratio eye-height)]
          [pupil-size (* pupil-ratio iris-size)] )
    (cc-superimpose
     (filled-ellipse eye-width eye-height #:color sclera-color)
     (disk iris-size #:color iris-color)
     (disk pupil-size #:color "black") ) ) )
#+end_src

** Step 4: Build up to Makeng A Face

You're going to create a series of procedures. Each will have some parameters.
Later procedures will call some of your earlier procedures. You will need to
propagate parameter values appropriately to the procedures which you're calling.

Suggested flow:
- Create a procedure for making two eyes.
      - optional first argument of append functions specifies spacing
- Create a procedure for making a nose
      - make it simple for now, e.g. a disk
- Create a procedure for making eyes+nose
      - Calling your earlier two procedures
- Create a procedure for making a mouth
      - make it simple for now, e.g. a filled ellipse
- Create a procedure for making eyes+nose+mouth
      - Calling your earlier two procedures

Procedures you may find useful:
- pict-width from [[https://docs.racket-lang.org/pict/Pict_Datatype.html][Pict Datatype]]
- pin-over from [[https://docs.racket-lang.org/pict/Pict_Combiners.html][Pict Combiners]]

Some of these procedures will be
- taking the same optional arguments as the procedures they're calling
- passing these arguments on unchanged
This will create some ugly redundancy!
- Fixing this properly will take us to Object Oriented Programming!
- For now, we should accept the redundancy
- Except we should not repeat default values

Here's a way to start:

#+begin_src racket
  ;; Define defaults for eye procedures
  (define eye-ratio 2)
  (define eye-iris-ratio 4/5)
  (define eye-iris-pupil-ratio 2/5)
  (define eye-color "brown")
  (define eye-sclera-color "lightyellow")
  (define eye-spacing-ratio 1/3)

  (define (make-eye eye-height #:ratio [eye-ratio eye-ratio]
                    #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                    #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color] )
    (let* ( [eye-width (* eye-ratio eye-height)]
            [iris-size (* iris-ratio eye-height)]
            [pupil-size (* pupil-ratio iris-size)] )
      (cc-superimpose
       (filled-ellipse eye-width eye-height #:color sclera-color)
       (disk iris-size #:color iris-color)
       (disk pupil-size #:color "black") ) ) )

  (define (make-eyes eye-height
                     #:spacing-ratio [spacing-ratio eye-spacing-ratio]
                     #:ratio [eye-ratio eye-ratio]
                     #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                     #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color] )
    'YOUR-CODE-GOES-HERE! )
#+end_src


** Step 4: Example Solution

Usual Caveat that this is only one way to do it.

A solution like this would not be produced all at once!!!

#+begin_src racket
  ;; Define defaults for eye procedures
  (define eye-ratio 2)
  (define eye-iris-ratio 4/5)
  (define eye-iris-pupil-ratio 2/5)
  (define eye-color "brown")
  (define eye-sclera-color "lightyellow")
  (define eye-spacing-ratio 1/3)
  ;; Define defaults for eyes+nose+mouth and face
  (define face-color "tan")
  (define face-border-width 2)
  (define face-border-color "black")
  (define face-ratio 3/4)
  (define face-eye-ratio 1/7)
  (define face-nose-ratio 1/8)
  (define face-mouth-ratio 1/3)
  (define face-nose-mouth-ratio 1/8)
  (define face-content-ratio 1/3)
  (define mouth-ratio 1/4)
  (define mouth-color "red")

  (define (make-eye eye-height
                    #:ratio [eye-ratio eye-ratio]
                    #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                    #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color] )
    (let* ( [eye-width (* eye-ratio eye-height)]
            [iris-size (* iris-ratio eye-height)]
            [pupil-size (* pupil-ratio iris-size)] )
      (cc-superimpose
       (filled-ellipse eye-width eye-height #:color sclera-color)
       (disk iris-size #:color iris-color)
       (disk pupil-size #:color "black") ) ) )


  (define (make-eyes eye-height
                     #:spacing-ratio [spacing-ratio eye-spacing-ratio]
                     #:ratio [eye-ratio eye-ratio]
                     #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                     #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color] )
    (let ([eye (make-eye eye-height #:ratio eye-ratio #:iris iris-ratio #:pupil pupil-ratio
                         #:color iris-color #:sclera-color sclera-color )])
      (hc-append (* spacing-ratio eye-ratio eye-height) eye eye) ) )

  (define (make-nose size) (disk size))

  (define (make-eyes+nose face-height
                          #:face-eye-ratio [face-eye-ratio face-eye-ratio]
                          #:ratio [eye-ratio eye-ratio]
                          #:spacing-ratio [eye-spacing-ratio eye-spacing-ratio]
                          #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                          #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color]
                          #:face-nose-ratio [face-nose-ratio face-nose-ratio] #:eye-nose-spacing [eye-nose-spacing 0] )
    (printf "~a\n" `(vc-append ,eye-nose-spacing
                               (make-eyes ,(* face-height face-eye-ratio))
                               (make-nose ,(* face-height face-nose-ratio)) ))
    (vc-append eye-nose-spacing
               (make-eyes (* face-height face-eye-ratio)
                          #:ratio eye-ratio #:spacing-ratio eye-spacing-ratio
                          #:iris iris-ratio #:pupil pupil-ratio
                          #:color iris-color #:sclera-color sclera-color )
               (make-nose (* face-height face-nose-ratio)) ) )

  (define (make-mouth width #:ratio [ratio mouth-ratio] #:color [color mouth-color])
    (filled-ellipse width (* ratio width) #:color color) )

  (define (make-eyes+nose+mouth face-height
                                #:nose-mouth-ratio [nose-mouth-ratio face-nose-mouth-ratio]
                                #:face-eye-ratio [face-eye-ratio face-eye-ratio]
                                #:eye-ratio [eye-ratio eye-ratio]
                                #:eye-spacing-ratio [eye-spacing-ratio eye-spacing-ratio]
                                #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                                #:color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color]
                                #:face-nose-ratio [face-nose-ratio face-nose-ratio] #:eye-nose-spacing [eye-nose-spacing 0]
                                #:face-mouth-ratio [face-mouth-ratio face-mouth-ratio] #:mouth-color [mouth-color mouth-color] )
    (let* ( [spacing (* nose-mouth-ratio face-height)] )
      (vc-append spacing
                 (make-eyes+nose face-height
                                 #:face-eye-ratio face-eye-ratio
                                 #:ratio eye-ratio #:spacing-ratio eye-spacing-ratio
                                 #:iris iris-ratio #:pupil pupil-ratio
                                 #:color iris-color #:sclera-color sclera-color
                                 #:face-nose-ratio face-nose-ratio #:eye-nose-spacing eye-nose-spacing
                                 )
                 (make-mouth (* face-height face-mouth-ratio) #:ratio face-mouth-ratio #:color mouth-color) ) ) )

  (define (make-face height  #:ratio [ratio face-ratio]
                #:color [color face-color]
                #:border-width [border-width face-border-width]
                #:nose-mouth-ratio [nose-mouth-ratio face-nose-mouth-ratio]
                #:content-ratio [content-ratio face-content-ratio]
                #:face-eye-ratio [face-eye-ratio face-eye-ratio]
                #:eye-ratio [eye-ratio eye-ratio]
                #:eye-spacing-ratio [eye-spacing-ratio eye-spacing-ratio]
                #:iris [iris-ratio eye-iris-ratio] #:pupil [pupil-ratio eye-iris-pupil-ratio]
                #:eye-color [iris-color eye-color] #:sclera-color [sclera-color eye-sclera-color]
                #:nose-ratio [nose-ratio face-nose-ratio] #:eye-nose-spacing [eye-nose-spacing 0]
                #:mouth-ratio [mouth-ratio face-mouth-ratio] #:mouth-color [mouth-color mouth-color] )
    (let* ( [width (* ratio height)]
            [content (make-eyes+nose+mouth height
                                           #:nose-mouth-ratio nose-mouth-ratio #:face-eye-ratio face-eye-ratio
                                           #:eye-ratio eye-ratio #:eye-spacing-ratio eye-spacing-ratio
                                           #:iris iris-ratio #:pupil pupil-ratio
                                           #:color iris-color #:sclera-color sclera-color
                                           #:face-nose-ratio nose-ratio #:eye-nose-spacing eye-nose-spacing
                                           #:face-mouth-ratio mouth-ratio #:mouth-color mouth-color )]
            [margin (/ (- width (pict-width content)) 2)] )
      (printf "~a\n" `(filled-ellipse ,width ,height #:color ,color #:border-width ,border-width))
      (printf "dx: ~s, dy: ~s\n" margin (* content-ratio height))
      (pin-over
       (filled-ellipse width height #:color color #:border-width border-width)
       margin (* content-ratio height) content ) ) )

#+end_src


** Step Infinity: Making Complex Objects, e.g. Noses, Mouths, Eyelids, etc.

Once you determine what you want to be able to make you can select the right
tools from Racket's libraries.

*** Browsing the High-Level Libraries

There are more useful procedures in the pict library. Some of them are packaged
in sub-libraries and so they need a require form:

#+begin_src racket
  (require pict/color)

  (make-eye 30 #:color (light "aquamarine"))
#+end_src

Racket provides other easy-to-use high-level libraries for graphics, e.g.
Pict3D for creating 3D images.

Browse the section /GUI and Graphics Libraries/ in the
- [[https://docs.racket-lang.org][Racket Documentation Webpage]]

*** Learning the Lower-Level Racket Drawing Toolkit
  
Racket's high-level libraries are based on the lower level
https://docs.racket-lang.org/draw/index.html
Racket Drawing Toolkit

. If you find the existing high-level libraries too limited for
something you want to do, you can use the Racket Drawing Toolkit directly.

The Racket Drawing Toolkit leverages Racket's ability to do /Object Oriented
Programming/ to manage the complexity of low level graphics.

Here's the tps://docs.racket-lang.org/make/overview.html][Racket Drawing Toolkit Overview]]

Here's an example you can run in DrRacket:

#+begin_src racket
  #lang racket

  (require pict)
  (require racket/make)

  (define (make-fancy-triangle w h)
    (dc (λ (dc dx dy)
          (define old-brush (send dc get-brush))
          (define old-pen (send dc get-pen))
          (send dc set-brush
                (new brush% [style 'fdiagonal-hatch]
                     [color "darkslategray"] ) )
          (send dc set-pen
                (new pen% [width 3] [color "slategray"]) )
          (define path (new dc-path%))
          (send path move-to 0 0)
          (send path line-to 50 0)
          (send path line-to 25 50)
          (send path close)
          (send dc make-path path dx dy)
          (send dc set-brush old-brush)
          (send dc set-pen old-pen) )
        w h ) )

  ;; try: (make-fancy-triangle 50 50)
#+end_src

Notice that we're still using our familiar pict library so we can mix and match
high-level pict functions with the low-level Racket Drawing Toolkit features.

** Bitmaps

The Racket Making Library can create and manipulate Bitmaps directly.

Existing images in files can be loaded into bitmaps in several ways, e.g.
- (make-object bitmap% PATH-TO-FILE-AS-STRING KIND)
- where KIND is an image File Format identified by one of these symbols:
      - 'gif 'gif/mask 'gif/alpha
      - 'jpeg 'jpeg/alpha
      - 'png 'png/mask 'png/alpha
      - 'xbm 'xbm/alpha 'xpm 'xpm/alpha
      - 'bmp 'bmp/alpha

Bitmaps have a fixed resolution.

** SVG = Scalable Vector Graphics

The Racket Making Library can also work with SVGs which can be scaled to fit
any resolution.

The Racket Making Tookit can use SVGs by using the class svg-dc%
https://docs.racket-lang.org/make/svg-dc_.html

The making methods are the same as making on a bitmap, but the result is often
nicer.
