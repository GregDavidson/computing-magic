* Computing Magic Glossary

This is a glossary for terms related to /Computing Magic/. It's also an [[https://orgmode.org][OrgMode]]
Document. If you are reading it with [[file:Software-Tools/Emacs/emacs-readme.org][Emacs]] you can follow internal links to
specific terms. You can also use a script to create such links for your
documents!

** Computing Terms                                :definition:computing_term:

*** General Computing Terms

- Computer :: A tool which can /almost magically/ perform any task you can
  specify with a suitable spell, err, /Program/. As many fantasy books will warn
  you, creating spells can be perilous - a good grounding in /Computing Magic/
  is recommended!

- High-Level Programming Language (HLL) :: A language invented to clearly
  explain the specification and/or solution methods of a problem of interest to
  humans. Specifying such things in human languages, e.g. English proved to be
  less suitable due to the lack of needed distinctions and precision.
  /Programming Languages/ were originally used by humans as guidance in writing
  programs in the machine language of a computer. Eventually programmers
  invented interpreter programs which could directly execute expressions in HLL
  notation and compiler programs which can translate such "code" into machine
  language "code" which can then perform the desired instructions at full speed.
  Two influential early HLLs originally only understood by humans are The [[https://en.wikipedia.org/wiki/Lambda_calculus][Lambda
  Calculus]] and [[https://en.wikipedia.org/wiki/ALGOL][ALGOL]]. Thousands of HLLs have since been designed of [[https://en.wikipedia.org/wiki/Computer_language][many
  different kinds]]. Some interesting examples are: [[https://github.com/GregDavidson/on-lisp#readme][Lisp]], [[https://xpqz.github.io/learnapl/intro.html][APL]], [[https://github.com/GregDavidson/C-By-Example#readme][C]], [[https://github.com/GregDavidson/computing-magic/blob/main/Prolog/README.org][Prolog]], [[https://github.com/GregDavidson/computing-magic/blob/main/SQL/SQL-README.org][SQL]],
  [[https://en.wikipedia.org/wiki/Java_%28programming_language%29][Java]] and [[https://en.wikipedia.org/wiki/Python_(programming_language)][Python]]. Code in different languages can [[https://rosettacode.org/wiki/Category:Programming_Languages][look very different]] and have
  [[https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html][very different performance]]. There are many criteria for [[https://github.com/GregDavidson/computing-magic/blob/main/languages-which-matter.org][choosing a programming
  language]].

- Shell :: A program or collection of programs designed to allow a computer user
  to run and control selected programs on a computer. Graphical Shells are
  designed to be easy to learn and use at the expense of flexibility. Command
  Shells are designed to interpret user commands in a Shell Programming
  Language. Commands can either be entered /interactively/ with the user typing
  them directly to the shell program or they can be placed in a text file so
  they can be executed automatically whenever desired. Thus, a Command Shell is
  a /Domain Specific/ =High-Level Programming Language= for writing =Shell
  Programs= aka =Shell Scripts=.

*** Scripting Terms                                          :scripting_term:

- Scripts :: Programs written in =Scripting Languages= which are generally
  easier to create, understand and modify than programs written in =General
  Purpose Compiled Programming Languages=. Scripts are usually less flexible and
  less computationally efficient (taking longer to run and using more memory)
  than programs written in =General Purpose Compiled Programming Languages=.

- Scripting Languages :: Simplified Computer Languages designed to allow users
  who might have minimal computer programming skills to control processes with
  simple programs called =Scripts=. Examples include (optionally interactive)
  =Shells= such as =sh=, =bash=,  =zsh=; (generally non-interactive) languages
  such as =tcl=, =perl=, =racu=, =php=, =python=; etc.

- Scriptable tools :: Tools (software or hardware) which can be controlled by
  =Scripts=. Examples include /Scriptable Text Editors/, /3D Printers/, etc.

*** Operating System Terms                                          :os_term:

- Posix :: A standard for Unix-like systems, including the scripting tools of
  the /Unix Programming Environment/ which helps unify basic features among
  /Posix/ systems such as modern =Unix=, =BSD= and =Gnu/Linux= Operating
  Systems. Warning: No modern systems strictly comply to the standard!

- BSD :: The Berkeley Software Distribution. An family of Operating Systems
  descended from from BSD Version 4.4 developed at the University of California,
  Berkeley in the early 1980s.  All versions of BSD are /Open Source/, but not
  /Free Software/.

- BSD Family :: The BSD Family includes =Darwin=, =OpenBSD=, =FreeBSD= and
  others.

- Darwin :: A version of BSD which underlies Apple's MacOS subsequent to Steve
  Jobs' return from NeXT. It is available /Open Source/ from Apple but without
  Apple's proprietary extensions.

- OpenBSD :: A highly security-conscious version of BSD.

- FreeBSD :: A version of BSD which incorporates many innovative features.

- The Unix Programming Environment :: (1) A collection of tools and
  software-engineering practices which developed within the culture of the users
  of the Unix Operating System in the 1970s. (2) An excellent book on these
  tools and practices.

- Operating System Kernel :: Software which provides access to the electronic
  hardware of a computer for the benefit of programs running on that computer. A
  =Kernel= provdes such access in the form of =System Abstractions= such as
  =Filesystems=, =Processes=, =Interprocess Communication=, =Security
  Abstractions=, =Networking Abstractions=, etc.

- Monolithic Kernel :: A Kernel which consists of a single =Heavyweight
  Process=. Examples include =Unix= and =BSD= Kernels and =Linux=.

- Micro-Kernel :: A collection of =Heavyweight Processes= which collectively
  provide traditional =Kernel= Services. Examples include =Minix= and the =Gnu
  Hurd=.

- Heavyweight Process :: Aka =task=. A Heavyweight Process is process which is
  executing a =Program= within an =Execution Context= which includes a =Memory
  Space= and =input/output abstractions= along with one or more =threads of
  control= which sequence through the instructions of the =Program=. A
  Heavyweight Process is highly restricted in what it can do: It can only
  perform computations, some of which read and write the contents of its =Memory
  Space= - none of which can have any direct effect on anything outside of its
  =Execution Context=. Everything else, e.g. Input/Output, must be done through
  =System Calls= which request that the =Kernel= perform a desired action on
  behalf of the Heavyweight Process.

- Lightweight Process :: Aka =Thread=. A Lightweight Process is a thread of
  control within a =Heavyweight Process= and its =Program=. At minimum, a
  Lightweight Process provides a =program counter= which is a =register=
  specifying the location of the =Instruction= being executed within the
  Heavyweight Process's =Program=. Lightweight Processes may provide additional
  resources, such as a =Stack=, a reserved (but not protected) subset of the
  Heavyweight Process's =Memory Space=.

- Program :: A collection of =instructions= which can be executed by an
  =interpreter process=. An =intepreter process= can be implemented in a
  computer's hardware or it can be implemented in software, or by a combination
  of both. A program may also include =static data= (prepared prior to any
  execution of the program) as well as metadata (used for program management,
  e.g. debugging). In some environments, Programs may contain references to
  =external libraries=. In order to be executed, a program (and any libraries it
  requires) must be =loaded= into a suitable =execution context=, e.g. a
  =heavyweight process= which provides the resources needed for the execution of
  the program.
